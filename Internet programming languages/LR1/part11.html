<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Поиск в ширину</title>
</head>

<body>
    <h3>Алгоритм поиска в ширину(BFS)</h3>
    <p>Пусть задан <strong>граф</strong> <var>G</var> = (<var>V</var>, <var>E</var>), где <var>V</var> - кол-во вершин, 
    <var>E</var> -
    кол-во ребер графа, и дана <strong>исходная</strong> вершина s</p>
    
    <p>Алгоритм поиска в ширину обходит все ребра графа <var>G</var> для "открытия" всех вершин, достижимых из s,
    с целью вычисления расстояния от заданной вершины до других вершин графа и построения дерева предкоков.</p>
    <p>Алгоритм имеет название <strong>поиск в ширину</strong>, потому что на каждом этапе обхода рассматривает сначала все вершины, 
    связанные с рассматриваемой, и лишь потом переходит к рассмотрению другой вершины.<br>
    Условно говоря, если представить множетсво открытых вершин как дерево, то оно сначала будет увеличиваться в <em>ширину</em>,
    а когда расширение закончится, будет увеличиваться в длину(глубину).</p>
    <p>Для своей работы алгоритм <em>раскрашивает</em> врешины в черный(уже рассмотренные) и белый(еще не рассмотренные).
    Также можно ввести понятие серых вершин: вершины, которые уже были посещены алгоритмом, но не до конца обработы им, тогда эти
    серые вершины будут обозначать границу между рассмотренными и нерассмотренными вершинами.
    </p>
    <p>Ниже представлен код реализации BFS на C++. В данной реализиции мы храним граф в виде <em>списка смежности</em>:
    массива списков, где в <var>i-ом</var> списке хранятся вершины, которые связаны с <var>i-ой</var> вершиной.</p>
    <p><strong>Реализация:</strong><br>
    <code>
        vector&lt;vector&lt;int&gt;g(1010); //Список смежности<br>
        vector&lt;bool&gt; used(1010); //Массив, посещенных вершин<br>
        vector&lt;int&gt; d(1010); //Массив расстояний<br>
        vector&lt;int&gt; p(1010); //Массив предков<br>
             
        queue&lt;int&gt; q; //Очередь рассматриваемых вершин<br>
             
        void bfs(int s) {<br>
            d[s] = 0;<br>
            p[s] = -1;<br>
            used[s] = true;<br>
            q.push(s);<br>
            while (!q.empty()) {<br>
                int curr = q.front();<br>
                q.pop();<br>
                for (int i = 0; i &lt; g[curr].size(); i++) {<br>
                    if(!used[g[curr][i]]) {<br>
                        d[g[curr][i]] = d[curr] + 1;<br>
                        p[g[curr][i]] = curr;<br>
                        q.push(g[curr][i]);<br>
                        used[g[curr][i]] = true;<br>
                    }<br>
                }<br>
            }<br>
        }<br>
    </code>
    </p>
</body>

</html>